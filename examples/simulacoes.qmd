---
title: "Simulações"
format: html
editor: visual
---

```{r}

# install.packages("devtools")
# install.packages("tidyverse")
detach("package:mixRegEM")
# try(remove.packages("mixRegEM"))
devtools::install_github("PedroHCAlmeida/mixRegEM")
```

```{r}
matrizP <- function(alpha, R){
  P1 <- exp(R%*%alpha)/(1 + rowSums(exp(R%*%alpha)))
  P <- cbind(P1, 1 - rowSums(P1))
  return(P)
}

# Função auxiliar
cbind.fill <- function(...){
  nm <- list(...) 
  nm <- lapply(nm, as.matrix)
  n <- max(sapply(nm, nrow)) 
  do.call(cbind, lapply(nm, function (x) 
    rbind(x, matrix(, n-nrow(x), ncol(x))))) 
}
```

# Grupos pobremente separados

## Gerando grupo 1

```{r}
set.seed(123)
n = 3000
X = cbind(rep(1, n), rnorm(n, 5, 3), rnorm(n, 10, 5))
x = X[,-1]

R = cbind(rep(1, n), runif(n, -2, 1), runif(n, -1, 1))
r = R[,-1]

beta01 <- c(5, 6, -1)
alpha01 <- c(0.7, 1, 2)
sigma01 <- 100
mu01 <- X%*%beta01

alpha <- matrix(alpha01, byrow = T, nrow = 3)
P <- matrizP(alpha, R)
```

## Gerando grupo 2

```{r}
beta02 <- c(-10, 1, 4)
sigma02 <- 30
mu02 <- X%*%beta02
```

## Gerando Y

```{r}
obs = do.call(rbind, 
              lapply(1:n,
                     function(i){
                       mixsmsn::rmix(1, pii = P[i,], family = 'Normal', cluster = T,
                                     arg = list(list(mu = mu01[i,], sigma2 = sigma01, shape = 0), 
                                                list(mu = mu02[i,], sigma2 = sigma02, shape = 0)))
                     }))

y = unlist(obs[,1])
grupo = unlist(obs[,2]) 
```

# Analisando Grupos

```{r}
data.frame(grupo = as.factor(grupo), y = y) |>
  ggplot2::ggplot() +
  ggplot2::aes(x = y, fill = grupo) +
  ggplot2::geom_histogram(bins = 15, alpha=0.6, position = 'identity') +
  ggplot2::theme_minimal()
```

## Regressão Usual

```{r}
ml = lm(y ~ ., data.frame(cbind(x, y = y)))
summary(ml) 
```

## Modelo de misturas normal

```{r}
regMix = mixRegEM::regEM(y, x, g = 2, tol = 1E-6, grupoReal = grupo, verbose = F,
                         family = "MixNormal", initGrupo = "KMeans", min_iter = 1)

regMix$Parametros |>
  kableExtra::kable("html")
```


## Modelo de misturas de experts normal

```{r}
regMoe = mixRegEM::regEM(y, x, r = r, g = 2, tol = 1E-6, grupoReal = grupo, verbose = F,
                         family = "MoENormal", initGrupo = "KMeans", min_iter = 1)

regMoe$Parametros |>
  kableExtra::kable("html")
```

## Comparação modelos

```{r}
regMix$Parametros |>
  t() |>
  as.data.frame() |>
  tibble::rownames_to_column("Grupo") |>
  tidyr::pivot_longer(-Grupo, names_to = "Coeficiente",
                      values_to = "Mix") |>
  dplyr::left_join(regMoe$Parametros |>
                     t() |> 
                     as.data.frame() |>
                     tibble::rownames_to_column("Grupo") |>
                     tidyr::pivot_longer(-Grupo, names_to = "Coeficiente",
                                          values_to = "Moe") |>
                     dplyr::filter(!grepl("alpha", Coeficiente)), by = c("Grupo", "Coeficiente")) |>
  cbind("Simulação" = c(beta01, sqrt(sigma01), beta02, sqrt(sigma02))) |>
  kableExtra::kable("html") 
```


## Predição

```{r}
set.seed(938)
train_indexes = sample(1:n, n*0.7)

reg_moe_train = mixRegEM::regEM(y[train_indexes], 
                                x[train_indexes,], 
                                r = r[train_indexes,], g = 2, 
                                tol = 1E-6, verbose = F,
                                family = "MoENormal", initGrupo = "KMeans")

test_predict_pond = mixRegEM::predictMix(reg = reg_moe_train, 
                                         x = x[!train_indexes,],
                                         r = r[!train_indexes,],
                                         class = F)

```






































